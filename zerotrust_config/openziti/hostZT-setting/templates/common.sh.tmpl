#!/bin/bash

# ==============================================================================
# COMMON FUNCTIONS
# ==============================================================================

# Ziti configuration from variable_input.yml
ZITI_HOME="{{ ziti_config.ctrl.cloud_ctrl.home }}"
ZITI_CTRL_ADVERTISED_ADDRESS="{{ ziti_config.ctrl.cloud_ctrl.ctrl_advertised_address }}"
ZITI_CTRL_ADVERTISED_PORT="{{ ziti_config.ctrl.cloud_ctrl.ctrl_advertised_port }}"
ZITI_USER="{{ ziti_config.ctrl.cloud_ctrl.user }}"
ZITI_PWD="{{ ziti_config.ctrl.cloud_ctrl.password }}"

# --- Log a message ---
log() {
  #echo ">>> $(date '+%Y-%m-%d %H:%M:%S') - $1"
  echo ">>> $(date '+%Y-%m-%d %H:%M:%S.%N') - $1"
}

# --- Install Ziti CLI ---
install_ziti_cli() {
  apt install curl gpg -y
  log "Installing Ziti CLI"
  if ! command -v ziti &>/dev/null; then
    source /etc/os-release
    curl -sS https://get.openziti.io/install.bash | sudo bash -s openziti-router
    log "Ziti CLI installed."
  else
    log "Ziti CLI is already installed."

  fi
}

# --- Install Ziti Edge Tunnel ---
install_ziti_edge_tunnel() {
  log "Installing Ziti Edge Tunnel"
  if ! command -v ziti-edge-tunnel &>/dev/null; then
    curl -sSLf https://get.openziti.io/tun/package-repos.gpg |
    gpg --dearmor --output /usr/share/keyrings/openziti.gpg

    chmod -c +r /usr/share/keyrings/openziti.gpg

    echo "deb [signed-by=/usr/share/keyrings/openziti.gpg] https://packages.openziti.org/zitipax-openziti-deb-stable jammy main" |
      tee /etc/apt/sources.list.d/openziti.list >/dev/null

    apt update

    apt install -y ziti-edge-tunnel
    log "Ziti Edge Tunnel installed."
  else
    log "Ziti Edge Tunnel is already installed."
  fi

}

# --- Add Ziti DNS entries to /etc/hosts ---
add_ziti_dns_entries() {
  log "Adding Ziti DNS entries to /etc/hosts"
  cloud_ip="$1"
  
  # Ensure the entries are not already present
  if ! grep -q "{{  ziti_config.ctrl.cloud_ctrl.ctrl_advertised_address  }}" /etc/hosts; then
    echo "$cloud_ip {{  ziti_config.ctrl.cloud_ctrl.ctrl_advertised_address  }}" | sudo tee -a /etc/hosts
    echo "$cloud_ip {{  ziti_config.ctrl.cloud_ctrl.router.cloud_router_advertised_address  }}" | sudo tee -a /etc/hosts
  fi
  {% for edge in ziti_config.router.edge_router %}
  if ! grep -q "{{  edge.edge_router_advertised_address }}" /etc/hosts; then
    echo "{{ edge.edge_router_ip }} {{ edge.edge_router_advertised_address }}" | sudo tee -a /etc/hosts
  fi
  {% endfor %}
}


# --- Create and enroll a Ziti identity ---
create_and_enroll_identity() {
  identity_name="$1"
  identity_roles="$2"
  machine_name="$3"
  path="$4"
  jwt_file="${path}/${identity_name}.jwt"
  json_file="${path}/${identity_name}.json"

  log "Creating and enrolling identity: $identity_name  $machine_name"

  if [[ -n "$machine_name" ]]; then
    full_identity="${identity_name}-${machine_name}"
  else
    full_identity="$identity_name"
  fi

  ${ZITI_HOME}/bin/ziti edge login https://${ZITI_CTRL_ADVERTISED_ADDRESS}:${ZITI_CTRL_ADVERTISED_PORT} --yes -u ${ZITI_USER} -p ${ZITI_PWD}
  
  ${ZITI_HOME}/bin/ziti edge create identity device "$full_identity" -a "$identity_roles" --jwt-output-file "$jwt_file"

  ${ZITI_HOME}/bin/ziti edge enroll --jwt ${jwt_file} --out ${json_file}
  
}


# --- Function to create Ziti service and policies ---
create_ziti_service() {
  name="$1"
  port="$2"
  intercept_address="$3"
  host_address="$4"
  service_roles="$5"
  bind_identity_roles="$6"
  dial_identity_roles="$7"

  log "Creating Ziti service: $name"

  # Create intercept config
  "$ZITI_CLI" edge create config "${name}-intercept-config" intercept.v1 \
    "{\"protocols\":[\"tcp\"],\"addresses\":[\"${intercept_address}\"], \"portRanges\":[{\"low\":${port}, \"high\":${port}}]}"

  # Create host config
  "$ZITI_CLI" edge create config "${name}-host-config" host.v1 \
    "{\"protocol\":\"tcp\", \"address\":\"${host_address}\",\"port\":${port}}"

  # Create service
  "$ZITI_CLI" edge create service "${name}-service" \
    --configs "${name}-intercept-config,${name}-host-config" --role-attributes "$service_roles"

  # Create bind policy
  "$ZITI_CLI" edge create service-policy "${name}-bind-policy" Bind \
    --service-roles "@${name}-service" --identity-roles "$bind_identity_roles"

  # Create dial policy
  "$ZITI_CLI" edge create service-policy "${name}-dial-policy" Dial \
    --service-roles "@${name}-service" --identity-roles "$dial_identity_roles"
}

wait_for_deployment() {
  ns=$1
  deploy=$2
  echo "Waiting for deployment '$deploy' in namespace '$ns' to be ready..."

  success_msg="deployment \"$deploy\" successfully rolled out"
  timeout=180 # seconds
  interval=10 # seconds
  elapsed=0

  while true; do
    output=$(kubectl rollout status deployment/"$deploy" -n "$ns" --timeout=5s 2>&1 || true)

    if echo "$output" | grep -q "$success_msg"; then
      echo "$output"
      break
    else
      echo "Still waiting: $output"
    fi

    if [ "$elapsed" -ge "$timeout" ]; then
      echo "Timeout waiting for deployment $deploy in namespace $ns"
      exit 1
    fi

    sleep "$interval"
    elapsed=$((elapsed + interval))
  done
}

log() {
  echo -e "\n====== $1 ======\n"
}


setup_localhost() {
  ip=$1
  advertise=$2

  echo "$ip $advertise"
  log "/etc/hosts"
  echo "sudo sed -i.bak \"/$advertise/ s/^/# /\" /etc/hosts"
  sudo sed -i.bak "/$advertise/ s/^/# /" /etc/hosts

  if [ -z "$ip" ]; then
    echo "External IP is not assigned yet. Exiting or waiting..."
    exit 1
  else
    echo "External IP found: $ip"
    echo "$ip $advertise" | sudo tee -a /etc/hosts
  fi
}

setup_router(){
  router_id=$1
  router_namespace=$2
  router_advertise=$3

log "router"
# get a router enrollment token from the controller's management API
ziti edge create edge-router "$router_id" \
  --tunneler-enabled --jwt-output-file /tmp/$router_id.jwt

# subscribe to the openziti Helm repo
if ! helm repo list | grep -q "^openziti"; then
  echo "Adding Helm repo 'openziti'..."
  helm repo add "openziti" "https://openziti.github.io/helm-charts/"
else
  echo "Helm repo 'openziti' already exists. Skipping."
fi


# install the router chart with a public address

if ! kubectl get namespace "$router_namespace" >/dev/null 2>&1; then
  echo "Creating namespace: $router_namespace"
  kubectl create namespace "$router_namespace"
else
  echo "Namespace $router_namespace already exists."
fi

helm upgrade --install \
  "$router_id"  \
  openziti/ziti-router \
    --namespace $router_namespace \
    --set-file enrollmentJwt=/tmp/$router_id.jwt \
    --set ctrl.endpoint=$ctrl_advertise:443 \
    {%- if ziti_config.ctrl.cloud_ctrl.router.loadbalancer %}
    --set edge.service.type=LoadBalancer \
    {%- endif %}
    --set edge.advertisedHost=$router_advertise

}

login_zt() {
  ctrl_advertise=$1
  ctrl_pass=$2

  ziti edge login "$ctrl_advertise:443" \
    --yes --username admin \
    --password "$ctrl_pass"

}

wait_for_ip_and_advertise() {
  ip_var_name=$1
  advertise_var_name=$2
  ip_command=$3
  advertise_value=$4

  MAX_RETRIES=10
  RETRY_INTERVAL=5
  RETRIES=0

  while true; do
    local ip_value
    #local advertise_value

    ip_value=$(eval "$ip_command")
    #advertise_value=$(eval "$advertise_command")

    if [[ -n "$ip_value" && -n "$advertise_value" ]]; then
      eval "$ip_var_name=\"$ip_value\""
      eval "$advertise_var_name=\"$advertise_value\""
      break
    fi

    echo "Waiting for $ip_var_name or $advertise_var_name to be available..."
    sleep "$RETRY_INTERVAL"
    RETRIES=$((RETRIES + 1))

    if [ "$RETRIES" -ge "$MAX_RETRIES" ]; then
      echo "Timeout waiting for $ip_var_name and $advertise_var_name"
      exit 1
    fi
  done
}

